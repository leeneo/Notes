/*SQL 命令大全*/
--代表注释

/*计算字符串字节长度*/
select LEN('00000002201803291912093015984')
select LEN('汉字') //=2 ，汉字一般占两个字节。

insert into MemberInfo (RegisterTime) values(GETDATE()) --GETDATE()== 当前时间，精确到毫秒

/*分离附加*/

--分离数据库 

use master
sp_detach_db 'database_name'   

--附加数据库

--1,
use master
EXEC sp_attach_db @dbname = N'pubs', 
@filename1 = N'c:\Program Files\Microsoft SQL Server\MSSQL\Data\pubs.mdf', 
@filename2 = N'c:\Program Files\Microsoft SQL Server\MSSQL\Data\pubs_log.ldf' 
此功能将在未来版本的Microsoft SQL Server中删除。避免在新的开发工作中使用此功能，并计划修改当前使用此功能的应用程序。我们建议您使用CREATE DATABASE database_name FOR ATTACH来代替

--2,
use master
CREATE DATABASE newhotel_xyjd
ON PRIMARY (FILENAME = 'D:\data\newhotel_xyjd.mdf') 
FOR ATTACH 
GO


/*db命令*/
sp_helpdb 
sp_helpdb master
use master
create database TestDB
sp_renamedb 'TestDB','MyLocalDb'
sp_helpdb MyLocalDb


/*table命令*/
use MyLocalDb
sp_help	/*查询当前数据库中对象(表，视图等)*/

create table People(
	FirstName nvarchar(6),
	LastName nvarchar(4),
	Age int,
	ID int identity (1,1),
	Primary key (ID)
);

sp_help people;				--查询指定表结构

drop table People

truncate table tbname		--删除表内容，释放表空间，不删除表结构（定义）

delete from tbname			--清空表内容，保留表结构，同truncate

/*增加字段*/
alter table card_type add IsShowInWeChat varchar(1) NOT NULL DEFAULT ('Y')
/*修改字段长度*/
alter table wxStoreOrders alter column paytype varchar(36)
/*删除字段*/
alter table wxStoreOrders drop column paytype varchar(36)

/*视图*/

CREATE VIEW [dbo].[v_wx_NewOrders]
AS
select * from someTable1
union select * from someTable2

/*结果集命令*/

insert into People (LastName,FirstName,Age) values(N'张',N'三','29');
insert into People (LastName,FirstName,Age) values(N'李',N'飞','29');
insert into People (LastName,FirstName,Age) values('张1','三2','29');		--不管是varchar还是nvarchar结构表，这样插入中文 显示乱码
--N'张'与'张' 字节长度是一样的

select distinct FirstName from People

select * from people where id between 2 and 5;		--返回结果集中id<=5&>=2的记录

delete from MemberInfo where MemberName is null		--删除为空数据 is null


/*存储过程*/

--声明变量并赋值
declare @Bdate varchar(20),@Edate varchar(20)
set 
@Bdate='2017-10-01'
set 
@Edate='2018-02-16'

SELECT * from table where SYS_DATE >= @Bdate AND SYS_DATE <= @Edate group by REGCARD.S_CARD_TYPE,s_describe ORDER BY REGCARD.S_CARD_TYPE ASC


--创建链接服务器，远程执行数据库的存储过程
exec sp_addlinkedserver 'TestServer','','SQLOLEDB','120.76.41.xx'
exec sp_addlinkedsrvlogin 'TestServer','false',null,'sa','pwd'
exec sp_serveroption 'TestServer','rpc out','true' --这个允许调用链接服务器上的存储过程

--查询已有链接服务器
 select * from sys.servers

--调用远程服务器存储过程：
exec TestServer.数据库名.dbo.过程名 '参数'

--demo:
select * from TestServer.TestDB.dbo.regcard where s_print_no = '17376852911'
select * from [120.76.42.118]].TestDB.dbo.regcard where s_print_no = '17376852911'

declare @as_error varchar(200)
exec TestServer.TestDB.dbo.Usp_Insert_cardaccount3 '', '11', '消费', @as_error output
select @as_error

=============================================================================================================
/*SET QUOTED_IDENTIFIER ON 的作用*/

distinct 为sql server 标识符，可以通过加双引号的方式作对象名使用，但在QUOTED_IDENTIFIER 为off时加双引号是不起作用的
SET QUOTED_IDENTIFIER ON
create table "distinct"(  
 id int not  null constraint pk_1 primary   key,  
 value varchar(255),  
 flag int  
)  

SET QUOTED_IDENTIFIER ON
drop table "distinct"
--------------------- --------------------- --------------------- --------------------- 
当 SET QUOTED_IDENTIFIER 为 ON 时

标识符可以由双引号分隔，而文字必须由单引号分隔。
由双引号分隔的所有字符串都被解释为对象标识符。因此，加引号的标识符不必遵守 Transact-SQL 标识符规则。它们可以是保留关键字，并且可以包含 Transact-SQL 标识符中通常不允许的字符。
不能使用双引号分隔文字字符串表达式，而必须用单引号括住文字字符串。
如果单引号 (‘) 是文字字符串的一部分，则可以由两个单引号 (”) 表示。
当对数据库中的对象名使用保留关键字时，SET QUOTED_IDENTIFIER 必须为 ON。
当 SET QUOTED_IDENTIFIER 为 OFF 时（默认值）

标识符不可加引号，且必须遵守所有 Transact-SQL 标识符规则。有关更多信息，请参见使用标识符。
表达式中的文字字符串可以由单引号或双引号分隔。
如果文字字符串由双引号分隔，则可以在字符串中包含嵌入式单引号。
当在计算列或索引视图上创建或操作索引时

SET QUOTED_IDENTIFIER 必须为 ON。
有关计算列上的索引视图和索引所必需的 SET 选项设置的更多信息，请参见 SET 中的”使用 SET 语句时的注意事项”

=============================================================================================================
/*SET ANSI_NULLS ON 的作用*/

当 SET ANSI_NULLS 为 ON 时，即使 column_name 中包含空值，使用 WHERE column_name = NULL 的 SELECT 语句仍返回零行。 即使 column_name 中包含非空值，使用 WHERE column_name <> NULL 的 SELECT 语句仍返回零行。

当 SET ANSI_NULLS 为 OFF 时，等于 (=) 和不等于 (<>) 比较运算符不遵守 ISO 标准。 使用 WHERE column_name = NULL 的 SELECT 语句返回 column_name 中包含空值的行。 使用 WHERE column_name <> NULL 的 SELECT 语句返回列中包含非空值的行。 此外，使用 WHERE column_name <> XYZ_value 的 SELECT 语句返回所有不为 XYZ_value 也不为 NULL 的行。

当 SET ANSI_NULLS 为 ON 时，所有对 null 值的比较均取值为 UNKNOWN。 当 SET ANSI_NULLS 为 OFF 时，如果数据值为 NULL，则所有数据对空值的比较将取值为 TRUE。 如果未指定 SET ANSI_NULLS，则应用当前数据库的 ANSI_NULLS 选项设置。

=============================================================================================================
游标一般格式：
DECLARE 游标名称 CURSOR FOR SELECT 字段1,字段2,字段3,... FROM 表名 WHERE ...
OPEN 游标名称
FETCH NEXT FROM 游标名称 INTO 变量名1,变量名2,变量名3,...
WHILE @@FETCH_STATUS=0
??????? BEGIN
????????????????? SQL语句执行过程... ...
????????????????? FETCH NEXT FROM 游标名称 INTO 变量名1,变量名2,变量名3,...
??????? END
CLOSE 游标名称
DEALLOCATE 游标名称 (删除游标)
--------------------- 
demo:
 table1结构如下
?id??? int
?name? varchar(50)
 
?declare @id int
?declare @name varchar(50)
?declare cursor1 cursor for???????? --定义游标cursor1
?select * from table1?????????????? --使用游标的对象(跟据需要填入select文)
?open cursor1?????????????????????? --打开游标
 
?fetch next from cursor1 into @id,@name? --将游标向下移1行，获取的数据放入之前定义的变量@id,@name中
 
?while @@fetch_status=0?????????? --判断是否成功获取数据   进入循环
?begin
?update table1 set name=name+'1'
?where id=@id?????????????????????????? --进行相应处理(跟据需要填入SQL文)
 
?fetch next from cursor1 into @id,@name? --将游标向下移1行  相当于for(int i;i<n;i++) 中的i+1
?end
 
?close cursor1?????????????????? --关闭游标
?deallocate cursor1
--------------------- 
