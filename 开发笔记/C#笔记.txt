msdn中文API： https://docs.microsoft.com/zh-cn/

例：class Microsoft.Extensions.DependencyInjection.ServiceCollection
Inheritance 继承类:Object -> ServiceCollection
Implements 实现接口:IServiceCollection

例：interface Microsoft.Extensions.DependencyInjection
Derived 派生类:Microsoft.Extensions.DependencyInjection.ServiceCollection
Implements 实现接口:ICollection<ServiceDescriptor> IEnumerable<ServiceDescriptor> IList<ServiceDescriptor>
===========================================================================================================================


apiclient.invoke 方法 可以直接调用DAL中的查询类方法,参数是一个json 类的model。
var BindCard = ApiClient.Invoke<List<regcard>>("DCard", "GetMemberCard", openID, false);
T.PageSize = 10;
                T.s_account_no = T.s_account_no;
                 T.s_code = s_code;
                T.s_account_no = card.s_account_no;
                var query = ApiClient.Invoke<DataTables<MemberPrepaidDebitLog>>("DCard", "GetCardAccountLog", T);
apiclient.get 方法通过调用api控制器来间接查询数据，参数可通过拼接字符串的方式传递
ResponseData<List<Report_SellOut>> res = JsonConvert.DeserializeObject<ResponseData<List<Report_SellOut>>>(ApiClient.Get("/Report/SellOutTotal?" + "Bdate=" + data.Bdate + "&Edate=" + data.Edate + "&Type=" + data.Type));
            return View(res.data);

T 泛型 ，通用数据类型修饰符，实例化时必需指定具体类型
<T> 泛型约束符，实例化时指定具体的类型

public DateTime? _time=null;
"?" 问号表示允许为空；

C#中“？”有三种用法。
1、可空类型修饰符(？)：引用类型可以使用空引用表示一个不存在的值，而值类型通常不能表示为空，例如:string str=null;是正确的。int i=null；编译器将报错。为了使值类型也可为空，可空类型出现了，可空类型使用可空类型修饰符？来表示，表现形式为T?。例：int?表示是可空的整形，DateTime?表示为可空的时间。T?其实是System.Nullable<T>（泛型结构）的缩写形式，也就意味着当你用到T？时编译器在编译时会把T？编译成System.Nullable<T>的形式，例如：int?,编译后便是System.Nullable<int>的形式。更多细节待续……。

2、三元（运算符）表达式(条件:表达1？表达式2)  先判断条件表达的值是否为true,条件为真，执行表达式1；条件为假，执行表达式2。
a=3>4?3:4;输出为4。
a=3<4?3:4;输出为3。

3、空合并运算符(？？)：用于定义可空类型和引用类型的默认值。如果此运算符的左操作数不为 null，则此运算符将返回左操作数；否则返回右操作数。 例：a??b,当a为null时则返回b,a不为空时返回a本身。空合并运算符为右结合运算符，即操作时从右向左进行组合的。如，“a??b??c”的形式按“a??(b??c)”计算


lamda表达式=>匿名函数
param=>param*2 等价于
fn(int param){
   return param*2;
}
* => 兰姆达表达式，可解读为“goes to”，.net 3.5的新语法。左侧是输入参数（如果有），右边包含表达式或语句块。

Lambda 表达式是一种可用于创建委托或表达式目录树类型的匿名函数。通过使用 lambda 表达式，可以写入可作为参数传递或作为函数调用值返回的本地函数。Lambda 表达式对于编写 LINQ 查询表达式特别有用。

若要创建 Lambda 表达式，需要在 Lambda 运算符 => 左侧指定输入参数（如果有），然后在另一侧输入表达式或语句块。例如，lambda 表达式 x => x * x 指定名为 x 的参数并返回 x 的平方值

=> 运算符具有与赋值运算符 (=) 相同的优先级并且是右结合运算


1．关于bin目录和obj目录
Bin目录用来保存项目生成后程序集，它有Debug和Release两个版本，分别对应的文件夹为bin/Debug和bin/Release，这个文件夹是默认的输出路径，我们可以通过：项目属性—>配置属性—>输出路径来修改。
obj目录是用来保存每个模块的编译结果，在.NET中，编译是分模块进行的，编译整个完成后会合并为一个.DLL或.EXE保存到bin目录下。因为每次编译时默认都是采用增量编译，即只重新编译改变了的模块，obj保存每个模块的编译结果，用来加快编译速度。是否采用增量编译，可以通过：项目属性—>配置属性—>高级—>增量编译来设置。
2．“是否复制到本地”的设置问题
在添加引用时，.NET会记录添加的引用绝对路径，这些设置保存在“每用户”文件中，（Solution.csproj.user），可以通过记事本打开查看。也可以在：项目属性—>通用属性—>引用路径里面查看。如果设置复制到本地为true，在生成项目时会自动拷贝该DLL到项目生成文件夹中(bin目录)，否则不会拷贝。在生成项目时，对所添加的引用的是绝对路径，而在运行时程序集默认只在当前所在的路径下去找。要修改引用的路径，必须通过编程的方法去实现。使用References 对象。
具体参见：
http://msdn.microsoft.com/library/chs/default.asp?url=/library/CHS/vbcon/html/vblrfaddmethodreferences.asp


#region regionName
代码块
#endregion

#region 大纲功能折叠，使在大纲功能预览时，代码看起来更简洁


/* 异步函数的执行方式：
*  public async Task ExecAsync(){}
*  1，await x.ExecAsync()（将所在函数声明为async）
*  2，x.ExecAsync().Wait()
*/

C# 7.1(目前仅.net core 2.0 支持)：
1,可以使用 async 关键字标记 Main 方法（应用程序入口点）。
2,推断的元组名称。
3,默认表达式。

string.Compare(String strA, String strB, bool ignoreCase)：比较strA和strB的值是否相等；为真返回0，假返回-1；可以比较为null的值;ignoreCase为true时，忽略比较大小写；为false时，值相同但大小写不一致返回1；
web.config:<add key="IsDebug" value="true" />
string.Compare(ConfigurationManager.AppSettings["IsDebug"], "true", true) ;     ==>返回 0
string.Compare(ConfigurationManager.AppSettings["IsDebug"], "false", true) ;    ==>返回-1
string.Compare(ConfigurationManager.AppSettings["IsDebug"], "null", true) ;     ==>返回-1

空白字符判断，string.IsNullOrWhiteSpace VS string.IsNullOrEmpty
string.IsNullOrEmpty 只对无空格“”空字符有效
//update TicketDetail set Openid=' ' where AutoID='2'
if (!string.IsNullOrWhiteSpace(td.OpenID)) 
    return Json(new { success = false, msg = "这张套票已经被领取了~" });    //不会执行
if (!string.IsNullOrEmpty(td.OpenID))
    return Json(new { success = false, msg = "这张套票已经被领取了~" });    //会执行

匿名类&Json的结合使用
语法：var obj=new{Name=value};

//非控制器类内部使用
return Newtonsoft.Json.JsonConvert.SerializeObject(new Results(-1, ex.InnerException.Message));
return Newtonsoft.Json.JsonConvert.SerializeObject(new { code = -1, msg = ex.InnerException.Message });
//控制器类内部使用
JsonResult System.Web.Mvc.Json
return Json(new Results(-1, as_bill_no));
return Json(new { success = false, msg = "找不到此参数，请刷新后重试。" });

// 加上此条件：where T : class ，下行代码会报类型错误：T必须是引用类型
    var res = ApiClient.Get<bool>("/neworder/del/" + id);

    public static T Get<T>(string url)
    {
            return default(T);
    }
    public static T Get<T>(string url) where T : class
    {
            return default(T);
    }

执行动态SqlQuery查询语句，多次使用同一个SqlParameter（数组或集体就会报）时报“另一个 SqlParameterCollection 中已包含 SqlParameter”错误
EN：The SqlParameter is already contained by another SqlParameterCollection
{
    string sql = "Usp_wx_binding_Card @as_WeChatId,@as_telno,@as_cardno,@as_password,@as_type,@as_error out";
    string result = "";
    
    var param = new List<SqlParameter>();
    param.Add(new SqlParameter("@as_WeChatId", request.as_WeChatId));
    param.Add(new SqlParameter("@as_telno", request.as_telno));
    param.Add(new SqlParameter("@as_cardno", request.as_cardno));
    param.Add(new SqlParameter("@as_password", request.as_password));
    param.Add(new SqlParameter("@as_type", request.as_type));
    param.Add(new SqlParameter("@as_error", SqlDbType.NVarChar, 255) { Direction = ParameterDirection.Output, Value = request.as_error });

    var results = context.Database.SqlQuery<ProcedureReturn>(sql, param.ToArray()).FirstOrDefault();
    result = param[5].Value.ToString(); //得到OutPut类型值

    解决方案（第二次执行使用clone语法）：
    var results = db.Database.SqlQuery<ProcedureReturn>(sql, param.Select(x => ((ICloneable)x).Clone()).ToArray()).FirstOrDefault();
    bResult = param[5].Value.ToString(); //得到OutPut类型值
}

=================================================================================================================================
EntityState.Modified 再 SaveChanges 与直接SaveChanges 的区别

1，会更新实体所有字段
db.Entry(member).State = EntityState.Modified;
db.SaveChanges();

2，只更新修改的字段
regcard.s_tel = bRegcard.s_tel;
db.SaveChanges();


