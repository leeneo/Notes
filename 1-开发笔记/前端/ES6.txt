******************************************************************************************************************
Promise 是JavaScript中的一种异步编程范式，是异步编程的一种解决方案。
一个Promise对象表示一个即将完成但还未完成的操作。
鉴于JavaScript中异步和回调的编程风格， Promise模式可以有效地避免『Callback Hell』。
******************************************************************************************************************
回调函数的问题：

一是“回调地狱”，因为异步回调函数的特点：回调函数是作为异步函数的参数，一层一层嵌套，当嵌套过多，将使代码逻辑变得混乱，
也无法做好错误捕捉和处理（只能在回调函数内部 try catch）。

二是回调的执行方式不符合自然语言的线性思维方式，不容易被理解。

三是控制反转（控制权在其他人的代码上），假如异步函数是别人提供的库，我们把回调函数传进去，
我们并不能知道异步函数在调用回调函数之外做了什么事情。
******************************************************************************************************************
《JS异步编程之Promise》--https://segmentfault.com/a/1190000018265595

JS 是基于单线程事件循环的概念构建的，回调函数不会立即执行，由事件轮询去检测事件是否执行完毕，
当执行完有结果后，将结果放入回调函数的参数中，然后将回调函数添加到事件队列中等待被执行。

Promise 原理
首先，Promise 中文翻译为“承诺”， 是 JavaScript 的一种对象，表示承诺终将返回一个结果，无论成功还是失败。
Promise 有三个状态：等待中(pending)，完成(fullfilled)，失败(rejected)
Promise 的设计具有原子性（指事务的不可分割性），状态一旦从 pending 状态转换为 fullfilled 状态或者 rejected 状态后，
将不能被改变。

Promise 的优势
链式调用
Promise 使用 then 方法后还会返回一个新的 Promise 对象，便于我们传递状态数据，同时链式写法接近于同步写法，更符合线性思维。

错误捕捉
相比回调函数的错误无法在外部捕捉的问题，Promise 能够为一连串的异步调用提供错误处理。

控制反转再反转
由于第三方提供的异步函数，无法保证回调函数如何被执行，但是 Promise 的特点，能够保证异步函数只能被 resolve 一次，
以及始终以异步的形式执行代码。

可以利用 Promise.all 和 Promise.race 来解决 Promise 始终未决议和并行 Promise 嵌套的问题

Promise 的不足

首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消，
其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部，
第三，当处于pending状态时，无法得知目前进展到哪一个阶段（是刚刚开始还是即将完成）

每个 .then() 都是一个独立的作用域
假如有很多个 .then() 方法，就会创建很多个独立的作用域，那么将只能通过外面包裹一层函数作用域的闭包来共享状态数据

无法取消单个 .then()
当 Promise 链中任意一个 .then() 方法中有语句执行错误后，尽管经过 catch 方法的错误处理，还是并不会中断整个 Promise 链的执行。

无法得知进度
由于 Promise 只能从 pending 到 fullfilled 或 rejected 状态，无法得知 pending 阶段的进度。

总结：
Promise 是 ES6 提出的简化异步流程控制的新规范，强调异步任务的完成状态且具有原子性，这使得我们的代码更容易追踪和维护。
Promise 在事件轮询中属于异步事件队列中的微任务，而微任务总是一次性全部执行，而宏任务是每轮轮询执行一个

******************************************************************************************************************
setTimeout 到底是同步还是异步的
链接：https://www.jianshu.com/p/4c377e876dac

任务队列
我们把需要执行的代码看成一个个任务，把任务分成两种，同步任务(sknchronous)，异步任务(asynchronous)。
下面是它们的运行机制：
1.所有同步任务都在主线程上，形成一个执行栈
2.主线程之外还有一个“任务队列”，只要异步任务有了运行结果 ，就在任务队列中放一个事件
3.当执行栈中所有的任务执行完了，就去看看任务队列中有没有需要执行的事件 ，如果有的话，就结束它们的等待，进入执行栈 ，开始执行。
4.主线程不断重读上面三步
这里还是单线程，只是多了一个任务队列

除了放置异步任务的事件，"任务队列"还可以放置定时事件。
setTimeout()接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。

需要注意的是，setTimeout()只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，
主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，
回调函数一定会在setTimeout()指定的时间执行。

综上所述
setTimeout是单线程，类似异步，但不是异步 。
******************************************************************************************************************
三种异步编程模式：
1、Callbacks
2、Listeners
3、Promise

异步的三种实现方式
     1） 回调函数 
             回调函数不一定是异步 , 但异步一定有回调函数 
     2） 事件监听(观察者模式)
     3） promise 对象
******************************************************************************************************************



******************************************************************************************************************



******************************************************************************************************************